/*  Copyright (C) 2018-2019 Noble Research Institute, LLC

File: cvutil_bwthin.cpp

Author: Anand Seethepalli (aseethepalli@noble.org)
Principal Investigator: Larry York (lmyork@noble.org)
Root Phenomics Lab
Noble Research Institute, LLC

This file is part of Computer Vision UTILity toolkit (cvutil)

cvutil is free software: you can redistribute it and/or modify
it under the terms of the NOBLE RESEARCH INSTITUTE, GENERAL PUBLIC LICENSE.

cvutil is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
NOBLE RESEARCH INSTITUTE GENERAL PUBLIC LICENSE for more details.

You should have received a copy of the Noble Research Institute General Public License
along with cvutil.  If not, see <https://github.com/noble-research-institute/cvutil/blob/master/LICENSE>.
*/

// bwthin Implementation
//
// Source:
// Zicheng Guo and Richard W. Hall. 1989. Parallel thinning with two-subiteration algorithms. 
// Communications of the ACM, Vol 32, Issue 3 (March 1989), 359-373.
// 
// Lam, L., Seong-Whan Lee, and Ching Y. Suen, Thinning Methodologies-A Comprehensive Survey,
// IEEE Transactions on Pattern Analysis and Machine Intelligence, Vol 14, No. 9, September 1992.

// bwthin() function involves creation of a Look-Up-Table (LUT) to satisfy 
// the following conditions:
// * Xh(p) = 1
// * 2 <= min{n1(p), n2(p)} <= 3 | n1(p) = sum{k = 1 to 4} x_(2k - 1) V x_(2k)
//                                 n2(p) = sum{k = 1 to 4} x_(2k) V x_(2k + 1)
// * (x2 V x3 V x8') ^ x1 = 0 in first subiteration and its 180 degree rotation in second.
//
// The LUT tables for the bwthin() are autogenerated from the code below.
//
/*******************************************************************/
/*            Autogeneration of LUT tables from python             */
/*
xmask = []
lut1 = [] # For first sub-iteration
lut2 = [] # For second sub-iteration

for i in range(8):
    xmask.append(2 ** i)

for i in range(256):
    x = []

    for j in xmask:
        x.append(int((i & j) > 0))

    b = []
    n1 = 0
    n2 = 0

    for j in range(4):
        if x[2 * j] == 0 and (x[2 * j + 1] == 1 or x[(2 * j + 2) % 8] == 1):
            b.append(1)
        else:
            b.append(0)
        
        n1 += (x[2 * j] or x[2 * j + 1])
        n2 += (x[2 * j + 1] or x[(2 * j + 2) % 8])

    if sum(b) != 1 or min(n1, n2) < 2 or min(n1, n2) > 3:
        lut1.append(0)
        lut2.append(0)
        continue
    
    # lut1 specific
    if ((x[1] or x[2] or int(not(x[7]))) and x[0]) == 0:
        lut1.append(1)
    else:
        lut1.append(0)

    # lut2 specific
    if ((x[5] or x[6] or int(not(x[3]))) and x[4]) == 0:
        lut2.append(1)
    else:
        lut2.append(0)
*/

#include "cvutil_bwthin.h"

#include <thread>

using namespace std;
using namespace cv;

#define INDEX(_k) subsptr[nsubcols * (_k)] * datacols + subsptr[nsubcols * (_k) + 1]
#define _P   data[INDEX(i)]
#define LUT_KEY  (((__X7) << 7) + ((__X6) << 6) + ((__X5) << 5) + ((__X4) << 4) + ((__X3) << 3) + ((__X2) << 2) + ((__X1) << 1) + __X0)

#define S_ROWV(_k) subsptr[nsubcols * (_k)]
#define S_COLV(_k) subsptr[nsubcols * (_k) + 1]
#define S_CURRV(_k) subsptr[nsubcols * (_k) + 2]
#define S_PREVV(_k) subsptr[nsubcols * (_k) + 3]

#define S_ROW    S_ROWV(i)
#define S_COL    S_COLV(i)
#define S_CURR   S_CURRV(i)
#define S_PREV   S_PREVV(i)

#define DIRECT_ACCESS(_R, _C)   int(data[(_R) * datacols + (_C)] == 255)
#define INDEX_ACCESS(_idx)      S_PREVV((_idx))

#define SPARSE_ACCESS(ro, co, ishi, _x)                 \
{                                                       \
    key = (ro) * datacols + (co);                       \
    if (ishi)                                           \
    {                                                   \
        lo = i;                                         \
        hi = ((i + datacols + 3) >= nsubrows) ?         \
              nsubrows - 1 : (i + datacols + 3);        \
    }                                                   \
    else                                                \
    {                                                   \
        lo = ((i - datacols - 3) < 0) ?                 \
              0 : (i - datacols - 3);                   \
        hi = i;                                         \
    }                                                   \
    mset = 0;                                           \
    idx = ULONG_MAX;                                    \
                                                        \
    while((indsptr[hi] != indsptr[lo]) &&               \
          (key > ((unsigned long)indsptr[lo])) &&       \
          (key < ((unsigned long)indsptr[hi])))         \
    {                                                   \
        mid = lo + ((key - indsptr[lo]) *               \
                 (hi - lo) /                            \
                 (indsptr[hi] - indsptr[lo]));          \
        if (((unsigned long)indsptr[mid]) < key)        \
            lo = mid + 1;                               \
        else if (key < ((unsigned long)indsptr[mid]))   \
            hi = mid - 1;                               \
        else                                            \
        {                                               \
            (_x) = subsptr[nsubcols * mid + 3];         \
            idx = mid;                                  \
            mset++;                                     \
            break;                                      \
        }                                               \
    }                                                   \
    if (!mset)                                          \
    {                                                   \
        if (key == indsptr[lo])                         \
        {                                               \
            (_x) = subsptr[nsubcols * lo + 3];          \
            idx = lo;                                   \
        }                                               \
        else if (key == indsptr[hi])                    \
        {                                               \
            (_x) = subsptr[nsubcols * hi + 3];          \
            idx = hi;                                   \
        }                                               \
        else                                            \
        {                                               \
            (_x) = 0;                                   \
            idx = ULONG_MAX;                            \
        }                                               \
    }                                                   \
}

int lut1[256] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
    1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0,
    1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0,
    1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0,
    1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0 };

int lut2[256] = {
    0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1,
    0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0,
    0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1,
    0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

struct _thread_data
{
    unsigned char *data;
    int *subsptr;
    int *indsptr;
    int datacols;
    int datarows;
    int nsubcols;
    int nsubrows;
    int prevsum;
    int currsum;
    int subitr;
    int nthreads;
    int tid;
    int nstart;
    int nend;
};

Mat bwthin_helper::bwthin_st(Mat inputc, Mat subs, Mat inds)
{
    int i = 0;
    unsigned char *data = inputc.ptr<unsigned char>();

    int datacols = inputc.cols;
    int nsubcols = subs.cols;
    int nsubrows = subs.rows;
    int prevsum = 0, currsum = 0, mset = 0;
    int *subsptr = subs.ptr<int>();
    int *indsptr = inds.ptr<int>();
    int __X0, __X1, __X2, __X3, __X4, __X5, __X6, __X7;

    unsigned long key = 0, lo = 0, hi = 0, mid = 0, idx = ULONG_MAX;

    do
    {
        // Sub-iteration 1
        for (i = 0; i < nsubrows; i++)
        {
            if (S_CURR == 1)
            {
                __X0 = DIRECT_ACCESS(S_ROW, S_COL + 1);
                SPARSE_ACCESS(S_ROW - 1, S_COL, 0, __X2);
                if (idx != ULONG_MAX)
                {
                    int idxval = idx;
                    if ((INDEX(idxval) + 1) == INDEX(idxval + 1))
                        __X1 = INDEX_ACCESS(idxval + 1);
                    else
                        __X1 = 0;
                    if ((INDEX(idxval) - 1) == INDEX(idxval - 1))
                        __X3 = INDEX_ACCESS(idxval - 1);
                    else
                        __X3 = 0;
                }
                else
                {
                    SPARSE_ACCESS(S_ROW - 1, S_COL + 1, 0, __X1);
                    SPARSE_ACCESS(S_ROW - 1, S_COL - 1, 0, __X3);
                }

                if ((INDEX(i) - 1) == INDEX(i - 1))
                    __X4 = INDEX_ACCESS(i - 1);
                else
                    __X4 = 0;
                __X5 = DIRECT_ACCESS(S_ROW + 1, S_COL - 1);
                __X6 = DIRECT_ACCESS(S_ROW + 1, S_COL);
                __X7 = DIRECT_ACCESS(S_ROW + 1, S_COL + 1);

                if (lut1[LUT_KEY])
                {
                    _P = 0;
                    S_CURR = 0;
                }
            }
        }

        for (i = 0; i < nsubrows; i++)
            S_PREV = S_CURR;

        // Sub-iteration 2
        for (i = 0; i < nsubrows; i++)
        {
            if (S_CURR == 1)
            {
                __X0 = DIRECT_ACCESS(S_ROW, S_COL + 1);
                SPARSE_ACCESS(S_ROW - 1, S_COL, 0, __X2);
                if (idx != ULONG_MAX)
                {
                    int idxval = idx;
                    if ((INDEX(idxval) + 1) == INDEX(idxval + 1))
                        __X1 = INDEX_ACCESS(idxval + 1);
                    else
                        __X1 = 0;
                    if ((INDEX(idxval) - 1) == INDEX(idxval - 1))
                        __X3 = INDEX_ACCESS(idxval - 1);
                    else
                        __X3 = 0;
                }
                else
                {
                    SPARSE_ACCESS(S_ROW - 1, S_COL + 1, 0, __X1);
                    SPARSE_ACCESS(S_ROW - 1, S_COL - 1, 0, __X3);
                }

                if ((INDEX(i) - 1) == INDEX(i - 1))
                    __X4 = INDEX_ACCESS(i - 1);
                else
                    __X4 = 0;
                __X5 = DIRECT_ACCESS(S_ROW + 1, S_COL - 1);
                __X6 = DIRECT_ACCESS(S_ROW + 1, S_COL);
                __X7 = DIRECT_ACCESS(S_ROW + 1, S_COL + 1);

                if (lut2[LUT_KEY])
                {
                    _P = 0;
                    S_CURR = 0;
                }
            }
        }

        for (i = 0, currsum = 0, prevsum = 0; i < nsubrows; i++)
        {
            if (S_PREV)
                prevsum++;
            if (S_CURR)
                currsum++;
        }

        if (prevsum == currsum)
            break;

        for (int i = 0; i < nsubrows; i++)
            S_PREV = S_CURR;
    } while (1);

    return inputc;
}

void bwthin_thread_apply_lut(void *_pdata)
{
    _thread_data pdata = (*(_thread_data *)_pdata);
    int i = 0;
    int nstart = pdata.nstart;
    int nend2 = pdata.nend;
    int nend1 = nend2 - pdata.datarows - 2;
    int nend0 = nstart + pdata.datarows + 2;
    int *subsptr = pdata.subsptr;
    int *indsptr = pdata.indsptr;
    unsigned char *data = pdata.data;
    int nsubcols = pdata.nsubcols;
    int nsubrows = pdata.nsubrows;
    int datacols = pdata.datacols;
    int __X0, __X1, __X2, __X3, __X4, __X5, __X6, __X7, mset = 0;
    unsigned long key = 0, lo = 0, hi = 0, mid = 0, idx = ULONG_MAX;

    if (pdata.subitr == 0)
    {
        for (i = nstart; i < nend1; i++)
        {
            if (S_CURR == 1)
            {
                __X0 = DIRECT_ACCESS(S_ROW, S_COL + 1);
                SPARSE_ACCESS(S_ROW - 1, S_COL, 0, __X2);
                if (idx != ULONG_MAX)
                {
                    int idxval = idx;
                    if ((INDEX(idxval) + 1) == INDEX(idxval + 1))
                        __X1 = INDEX_ACCESS(idxval + 1);
                    else
                        SPARSE_ACCESS(S_ROW - 1, S_COL + 1, 0, __X1);
                    if ((INDEX(idxval) - 1) == INDEX(idxval - 1))
                        __X3 = INDEX_ACCESS(idxval - 1);
                    else
                        SPARSE_ACCESS(S_ROW - 1, S_COL - 1, 0, __X3);
                }
                else
                {
                    SPARSE_ACCESS(S_ROW - 1, S_COL + 1, 0, __X1);
                    SPARSE_ACCESS(S_ROW - 1, S_COL - 1, 0, __X3);
                }

                if ((INDEX(i) - 1) == INDEX(i - 1))
                    __X4 = INDEX_ACCESS(i - 1);
                else
                    SPARSE_ACCESS(S_ROW, S_COL - 1, 0, __X4);
                __X5 = DIRECT_ACCESS(S_ROW + 1, S_COL - 1);
                __X6 = DIRECT_ACCESS(S_ROW + 1, S_COL);
                __X7 = DIRECT_ACCESS(S_ROW + 1, S_COL + 1);

                if (lut1[LUT_KEY])
                {
                    _P = 0;
                    S_CURR = 0;
                }
            }
        }

        for (; i < nend2; i++)
        {
            if (S_CURR == 1)
            {
                if ((INDEX(i) + 1) == INDEX(i + 1))
                    __X0 = INDEX_ACCESS(i + 1);
                else
                    SPARSE_ACCESS(S_ROW, S_COL + 1, 1, __X0);
                SPARSE_ACCESS(S_ROW - 1, S_COL, 0, __X2);
                if (idx != ULONG_MAX)
                {
                    int idxval = idx;
                    if ((INDEX(idxval) + 1) == INDEX(idxval + 1))
                        __X1 = INDEX_ACCESS(idxval + 1);
                    else
                        SPARSE_ACCESS(S_ROW - 1, S_COL + 1, 0, __X1);
                    if ((INDEX(idxval) - 1) == INDEX(idxval - 1))
                        __X3 = INDEX_ACCESS(idxval - 1);
                    else
                        SPARSE_ACCESS(S_ROW - 1, S_COL - 1, 0, __X3);
                }
                else
                {
                    SPARSE_ACCESS(S_ROW - 1, S_COL + 1, 0, __X1);
                    SPARSE_ACCESS(S_ROW - 1, S_COL - 1, 0, __X3);
                }
                
                if ((INDEX(i) - 1) == INDEX(i - 1))
                    __X4 = INDEX_ACCESS(i - 1);
                else
                    SPARSE_ACCESS(S_ROW, S_COL - 1, 0, __X4);
                SPARSE_ACCESS(S_ROW + 1, S_COL, 1, __X6);
                if (idx != ULONG_MAX)
                {
                    int idxval = idx;
                    if ((INDEX(idxval) + 1) == INDEX(idxval + 1))
                        __X7 = INDEX_ACCESS(idxval + 1);
                    else
                        SPARSE_ACCESS(S_ROW + 1, S_COL + 1, 1, __X7);
                    if ((INDEX(idxval) - 1) == INDEX(idxval - 1))
                        __X5 = INDEX_ACCESS(idxval - 1);
                    else
                        SPARSE_ACCESS(S_ROW + 1, S_COL - 1, 1, __X5);
                }
                else
                {
                    SPARSE_ACCESS(S_ROW + 1, S_COL - 1, 1, __X5);
                    SPARSE_ACCESS(S_ROW + 1, S_COL + 1, 1, __X7);
                }
                
                if (lut1[LUT_KEY])
                {
                    _P = 0;
                    S_CURR = 0;
                }
            }
        }
    }
    else
    {
        for (i = nstart; i < nend1; i++)
        {
            if (S_CURR == 1)
            {
                __X0 = DIRECT_ACCESS(S_ROW, S_COL + 1);
                SPARSE_ACCESS(S_ROW - 1, S_COL, 0, __X2);
                if (idx != ULONG_MAX)
                {
                    int idxval = idx;
                    if ((INDEX(idxval) + 1) == INDEX(idxval + 1))
                        __X1 = INDEX_ACCESS(idxval + 1);
                    else
                        SPARSE_ACCESS(S_ROW - 1, S_COL + 1, 0, __X1);
                    if ((INDEX(idxval) - 1) == INDEX(idxval - 1))
                        __X3 = INDEX_ACCESS(idxval - 1);
                    else
                        SPARSE_ACCESS(S_ROW - 1, S_COL - 1, 0, __X3);
                }
                else
                {
                    SPARSE_ACCESS(S_ROW - 1, S_COL + 1, 0, __X1);
                    SPARSE_ACCESS(S_ROW - 1, S_COL - 1, 0, __X3);
                }

                if ((INDEX(i) - 1) == INDEX(i - 1))
                    __X4 = INDEX_ACCESS(i - 1);
                else
                    SPARSE_ACCESS(S_ROW, S_COL - 1, 0, __X4);
                __X5 = DIRECT_ACCESS(S_ROW + 1, S_COL - 1);
                __X6 = DIRECT_ACCESS(S_ROW + 1, S_COL);
                __X7 = DIRECT_ACCESS(S_ROW + 1, S_COL + 1);

                if (lut2[LUT_KEY])
                {
                    _P = 0;
                    S_CURR = 0;
                }
            }
        }

        for (; i < nend2; i++)
        {
            if (S_CURR == 1)
            {
                if ((INDEX(i) + 1) == INDEX(i + 1))
                    __X0 = INDEX_ACCESS(i + 1);
                else
                    SPARSE_ACCESS(S_ROW, S_COL + 1, 1, __X0);
                SPARSE_ACCESS(S_ROW - 1, S_COL, 0, __X2);
                if (idx != ULONG_MAX)
                {
                    int idxval = idx;
                    if ((INDEX(idxval) + 1) == INDEX(idxval + 1))
                        __X1 = INDEX_ACCESS(idxval + 1);
                    else
                        SPARSE_ACCESS(S_ROW - 1, S_COL + 1, 0, __X1);
                    if ((INDEX(idxval) - 1) == INDEX(idxval - 1))
                        __X3 = INDEX_ACCESS(idxval - 1);
                    else
                        SPARSE_ACCESS(S_ROW - 1, S_COL - 1, 0, __X3);
                }
                else
                {
                    SPARSE_ACCESS(S_ROW - 1, S_COL + 1, 0, __X1);
                    SPARSE_ACCESS(S_ROW - 1, S_COL - 1, 0, __X3);
                }

                if ((INDEX(i) - 1) == INDEX(i - 1))
                    __X4 = INDEX_ACCESS(i - 1);
                else
                    SPARSE_ACCESS(S_ROW, S_COL - 1, 0, __X4);
                SPARSE_ACCESS(S_ROW + 1, S_COL, 1, __X6);
                if (idx != ULONG_MAX)
                {
                    int idxval = idx;
                    if ((INDEX(idxval) + 1) == INDEX(idxval + 1))
                        __X7 = INDEX_ACCESS(idxval + 1);
                    else
                        SPARSE_ACCESS(S_ROW + 1, S_COL + 1, 1, __X7);
                    if ((INDEX(idxval) - 1) == INDEX(idxval - 1))
                        __X5 = INDEX_ACCESS(idxval - 1);
                    else
                        SPARSE_ACCESS(S_ROW + 1, S_COL - 1, 1, __X5);
                }
                else
                {
                    SPARSE_ACCESS(S_ROW + 1, S_COL - 1, 1, __X5);
                    SPARSE_ACCESS(S_ROW + 1, S_COL + 1, 1, __X7);
                }

                if (lut2[LUT_KEY])
                {
                    _P = 0;
                    S_CURR = 0;
                }
            }
        }
    }
}

void bwthin_thread_copy_data(void *_pdata)
{
    _thread_data pdata = (*(_thread_data *)_pdata);
    int i = 0;
    int nstart = pdata.nstart;
    int nend = pdata.nend;
    int nsubcols = pdata.nsubcols;
    int *subsptr = pdata.subsptr;

    for (i = nstart; i < nend; i++)
        S_PREV = S_CURR;
}

void bwthin_thread_pixel_sums(void *_pdata)
{
    _thread_data *pdata = (_thread_data *)_pdata;
    int i = 0, currsum = 0, prevsum = 0;
    int nstart = pdata->nstart;
    int nend = pdata->nend;
    int nsubcols = pdata->nsubcols;
    int *subsptr = pdata->subsptr;

    for (i = nstart, currsum = 0, prevsum = 0; i < nend; i++)
    {
        if (S_PREV)
            prevsum++;
        if (S_CURR)
            currsum++;
    }

    pdata->currsum = currsum;
    pdata->prevsum = prevsum;
}

Mat bwthin_helper::bwthin_mt_thread(Mat inputc, Mat subs, Mat inds)
{
    int nthreads = getNumberOfCPUs();
    vector<thread> threads(nthreads);
    _thread_data *_pdata = new _thread_data[nthreads];
    unsigned char *data = inputc.ptr<unsigned char>();
    
    int i;
    int prevsum = 0, currsum = 0;
    int *subsptr = subs.ptr<int>();
    int *indsptr = inds.ptr<int>();

    for (i = 0; i < nthreads; i++)
    {
        _pdata[i].currsum = 0;
        _pdata[i].prevsum = 0;
        _pdata[i].datacols = inputc.cols;
        _pdata[i].datarows = inputc.rows;
        _pdata[i].nsubcols = subs.cols;
        _pdata[i].nsubrows = subs.rows;
        _pdata[i].subitr = 0;
        _pdata[i].tid = i;
        _pdata[i].nthreads = nthreads;
        _pdata[i].data = data;
        _pdata[i].indsptr = indsptr;
        _pdata[i].subsptr = subsptr;

        if (i == 0)
            _pdata[i].nstart = 0;
        else
            _pdata[i].nstart = _pdata[i - 1].nend;

        if (i == (nthreads - 1))
            _pdata[i].nend = subs.rows;
        else
            _pdata[i].nend = ((i + 1) * subs.rows) / nthreads;
    }

    do
    {
        // Sub-iteration 1
        for (i = 0; i < nthreads; i++)
        {
            _pdata[i].subitr = 0;
            threads[i] = thread(bwthin_thread_apply_lut, ((void *)&_pdata[i]));
        }

        for (i = 0; i < nthreads; i++)
            threads[i].join();

        // Data copy
        for (i = 0; i < nthreads; i++)
            threads[i] = thread(bwthin_thread_copy_data, ((void *)&_pdata[i]));

        for (i = 0; i < nthreads; i++)
            threads[i].join();

        // Sub-iteration 2
        for (i = 0; i < nthreads; i++)
        {
            _pdata[i].subitr = 1;
            threads[i] = thread(bwthin_thread_apply_lut, ((void *)&_pdata[i]));
        }

        for (i = 0; i < nthreads; i++)
            threads[i].join();

        // Compute pixel sums
        for (i = 0; i < nthreads; i++)
            threads[i] = thread(bwthin_thread_pixel_sums, ((void *)&_pdata[i]));

        for (i = 0; i < nthreads; i++)
            threads[i].join();

        // Consolidate pixel sums from all threads
        for (i = 0, prevsum = 0, currsum = 0; i < nthreads; i++)
        {
            prevsum += _pdata[i].prevsum;
            currsum += _pdata[i].currsum;
        }

        if (prevsum == currsum)
            break;

        // Data copy
        for (i = 0; i < nthreads; i++)
            threads[i] = thread(bwthin_thread_copy_data, ((void *)&_pdata[i]));

        for (i = 0; i < nthreads; i++)
            threads[i].join();
    } while (1);

    delete[] _pdata;
    return inputc;
}

